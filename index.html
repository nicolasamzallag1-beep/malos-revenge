<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Malo's Revenge - Circus Massacre</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Orbitron', sans-serif;
      background: linear-gradient(135deg, #1a0033 0%, #330033 50%, #660033 100%);
      color: #fff;
      overflow: hidden;
      height: 100vh;
    }

    #gameCanvas {
      display: block;
      background: radial-gradient(circle at 50% 50%, #2a0a3a, #0a0015);
      cursor: crosshair;
      border: 3px solid #ff00ff;
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
    }

    #startScreen, #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.9);
      z-index: 10;
    }

    h1 {
      font-size: 4rem;
      font-weight: 900;
      text-transform: uppercase;
      background: linear-gradient(45deg, #ff0080, #ff8c00, #40e0d0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 1rem;
      text-shadow: 0 0 20px rgba(255, 0, 128, 0.8);
    }

    p {
      font-size: 1.2rem;
      margin-bottom: 2rem;
      text-align: center;
      max-width: 600px;
      line-height: 1.6;
    }

    button {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      font-weight: 700;
      padding: 15px 40px;
      margin: 10px;
      border: 3px solid #ff00ff;
      background: linear-gradient(135deg, #ff0080, #ff8c00);
      color: #fff;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.3s;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }

    button:hover {
      transform: scale(1.1);
      box-shadow: 0 0 40px rgba(255, 0, 255, 0.9);
    }

    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 1.5rem;
      font-weight: 700;
      z-index: 5;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    #pauseBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 5;
      padding: 10px 20px;
      font-size: 1rem;
    }

    .hidden {
      display: none !important;
    }

    #finalMessage {
      font-size: 1.5rem;
      font-weight: 700;
      margin: 20px 0;
      color: #ff00ff;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="startScreen">
    <h1>üé™ Malo's Revenge üé™</h1>
    <p>
      Bienvenue dans le cirque le plus trash de l'histoire ! <br>
      Malo en a marre. Il veut sa revanche. <br>
      Lance des bouteilles de vin sur tes potes qui d√©filent. <br>
      Ils vont pleurer, te faire un doigt d'honneur, et toi tu vas kiffer. <br>
      Choisis ton niveau de difficult√© et que le massacre commence ! üç∑üíÄ
    </p>
    <div>
      <button onclick="startGame('easy')">Facile (Ap√©ro tranquille)</button>
      <button onclick="startGame('medium')">Moyen (Soir√©e qui d√©rape)</button>
      <button onclick="startGame('hard')">Difficile (Lendemain de cuite)</button>
    </div>
  </div>

  <div id="gameOverScreen" class="hidden">
    <h1>Game Over !</h1>
    <p id="finalScore"></p>
    <p id="finalMessage"></p>
    <button onclick="location.reload()">Rejouer</button>
  </div>

  <div id="hud" class="hidden">
    <div>Score: <span id="score">0</span></div>
    <div>Temps: <span id="timer">60</span>s</div>
  </div>

  <button id="pauseBtn" class="hidden" onclick="togglePause()">Pause</button>

  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let gameState = 'start';
    let score = 0;
    let timeLeft = 60;
    let isPaused = false;
    let difficulty = 'medium';

    const friends = [
      { name: 'malo', img: 'https://nicolasamzallag1-beep.github.io/malos-revenge/malo.jpg' },
      { name: 'marie', img: 'https://nicolasamzallag1-beep.github.io/malos-revenge/marie.jpg' },
      { name: 'ptitnico', img: 'https://nicolasamzallag1-beep.github.io/malos-revenge/nico.jpg' },
      { name: 'valentine', img: 'https://nicolasamzallag1-beep.github.io/malos-revenge/valentine.jpg' },
    ];

    const loadedImages = {};
    let imagesLoaded = 0;

    friends.forEach(friend => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        imagesLoaded++;
        loadedImages[friend.name] = img;
      };
      img.onerror = () => {
        console.error(`Erreur de chargement: ${friend.img}`);
        imagesLoaded++;
      };
      img.src = friend.img;
    });

    const targets = [];
    const bottles = [];
    const particles = [];

    const hitMessagesByCharacter = {
      malo: [
        "C'est qui √ßa ?",
        "On t'a d√©j√† vu quelque part ?",
        "On va faire comme si rien ne s'√©tait pass√©.",
        "T'es perdu fr√©rot ?",
        "La vie est injuste!",
        "Fr√©rot‚Ä¶ c'√©tait pas ton jour.",
        "Ok, j'avoue‚Ä¶ bien jou√©.",
      ],
      marie: [
        "Je vais te gifler !",
        "PAS d'accord.",
        "Oups,√ßa part en drame.",
        "T'as un probl√®me ?",
        "On va te d√©gommer",
        "√áa va finir au tribunal.",
        "C'est officiel: tu cherches.",
      ],
      ptitnico: [
        "Rastafarai !",
        "On dirait un probl√®me.",
        "Bad vibes ",
        "Merci d'avoir tent√©.",
        "Tu t'acharnes ?",
        "La vibe est cass√©e.",
        "C'est pas tr√®s zen √ßa.",
      ],
      valentine: [
        "Elle co√ªte cher !",
        "T'as vraiment cru que c'√©tait une bonne id√©e ?",
        "C'√©tait hors budget, d√©sol√©.",
        "Tout le monde n'a pas le niveau.",
        "Tu peux pas te le permettre.",
        "Retourne en version gratuite.",
        "D√©sol√©e, c'est premium ici.",
      ],
    };

    const missMessages = [
      "Rat√©. Le verre a v√©cu sa meilleure vie.",
      "Oups. Mauvaise trajectoire, bonne intention.",
      "Tu visais la t√™te, pas l'ambiance.",
      "√áa fr√¥le‚Ä¶ mais non.",
    ];

    const finalMessages = [
      { min: 0, max: 5, msg: "T'as m√™me pas essay√© ou quoi ? Retourne boire ton verre." },
      { min: 6, max: 15, msg: "Bon‚Ä¶ c'√©tait un d√©but. Mais faut s'entra√Æner encore." },
      { min: 16, max: 30, msg: "Pas mal ! T'as le potentiel d'un vrai tireur de soir√©e." },
      { min: 31, max: 50, msg: "Impressionnant ! T'es officiellement un danger public." },
      { min: 51, max: 999, msg: "L√âGENDE ! Malo est fier de toi. Le cirque est √† toi." },
    ];

    function startGame(level) {
      difficulty = level;
      gameState = 'playing';
      score = 0;
      timeLeft = 60;
      targets.length = 0;
      bottles.length = 0;
      particles.length = 0;

      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('hud').classList.remove('hidden');
      document.getElementById('pauseBtn').classList.remove('hidden');

      updateHUD();
      startTimer();
      spawnTargets();
      gameLoop();
    }

    function startTimer() {
      const timerInterval = setInterval(() => {
        if (gameState !== 'playing' || isPaused) return;
        timeLeft--;
        updateHUD();
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          endGame();
        }
      }, 1000);
    }

    function spawnTargets() {
      const spawnInterval = difficulty === 'easy' ? 2000 : difficulty === 'medium' ? 1500 : 1000;
      setInterval(() => {
        if (gameState !== 'playing' || isPaused) return;
        const friend = friends[Math.floor(Math.random() * friends.length)];
        const speedMultiplier = difficulty === 'easy' ? 1 : difficulty === 'medium' ? 1.5 : 2.5;
        const target = {
          x: Math.random() > 0.5 ? -100 : canvas.width + 100,
          y: Math.random() * (canvas.height - 200) + 100,
          width: 80,
          height: 80,
          speed: (Math.random() * 2 + 2) * speedMultiplier,
          direction: Math.random() > 0.5 ? 1 : -1,
          friend: friend,
          hit: false,
          hitTimer: 0,
        };
        targets.push(target);
      }, spawnInterval);
    }

    function updateHUD() {
      document.getElementById('score').textContent = score;
      document.getElementById('timer').textContent = timeLeft;
    }

    function togglePause() {
      isPaused = !isPaused;
      document.getElementById('pauseBtn').textContent = isPaused ? 'Reprendre' : 'Pause';
    }

    canvas.addEventListener('click', (e) => {
      if (gameState !== 'playing' || isPaused) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      bottles.push({
        x: x,
        y: canvas.height,
        targetY: y,
        speed: 15,
      });

      playSound('throw');
    });

    function gameLoop() {
      if (gameState !== 'playing') return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!isPaused) {
        updateBottles();
        updateTargets();
        updateParticles();
      }

      drawTargets();
      drawBottles();
      drawParticles();

      requestAnimationFrame(gameLoop);
    }

    function updateBottles() {
      for (let i = bottles.length - 1; i >= 0; i--) {
        bottles[i].y -= bottles[i].speed;
        if (bottles[i].y < 0) {
          bottles.splice(i, 1);
          showMessage(missMessages[Math.floor(Math.random() * missMessages.length)]);
        }
      }
    }

    function updateTargets() {
      for (let i = targets.length - 1; i >= 0; i--) {
        const target = targets[i];

        if (target.hit) {
          target.hitTimer++;
          if (target.hitTimer > 60) {
            targets.splice(i, 1);
          }
          continue;
        }

        target.x += target.speed * target.direction;

        if (target.x < -150 || target.x > canvas.width + 150) {
          targets.splice(i, 1);
        }

        for (let j = bottles.length - 1; j >= 0; j--) {
          const bottle = bottles[j];
          if (
            bottle.x > target.x &&
            bottle.x < target.x + target.width &&
            bottle.y > target.y &&
            bottle.y < target.y + target.height
          ) {
            target.hit = true;
            bottles.splice(j, 1);
            score += 10;
            updateHUD();
            createParticles(target.x + target.width / 2, target.y + target.height / 2);
            playSound('hit');
            const messages = hitMessagesByCharacter[target.friend.name];
            showMessage(messages[Math.floor(Math.random() * messages.length)]);
            break;
          }
        }
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function drawTargets() {
      targets.forEach(target => {
        if (loadedImages[target.friend.name]) {
          ctx.save();
          ctx.globalAlpha = target.hit ? 0.5 : 1;
          ctx.drawImage(loadedImages[target.friend.name], target.x, target.y, target.width, target.height);

          if (target.hit) {
            ctx.font = '40px Arial';
            ctx.fillText('üñïüò≠', target.x + 10, target.y + 50);
          }
          ctx.restore();
        } else {
          ctx.fillStyle = target.hit ? '#666' : '#ff00ff';
          ctx.fillRect(target.x, target.y, target.width, target.height);
          ctx.fillStyle = '#fff';
          ctx.font = '12px Orbitron';
          ctx.fillText(target.friend.name, target.x + 10, target.y + 40);
          if (target.hit) {
            ctx.font = '30px Arial';
            ctx.fillText('üñïüò≠', target.x + 10, target.y + 70);
          }
        }
      });
    }

    function drawBottles() {
      ctx.fillStyle = '#8B4513';
      bottles.forEach(bottle => {
        ctx.fillRect(bottle.x - 5, bottle.y - 15, 10, 15);
      });
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.fillStyle = `rgba(255, ${Math.floor(Math.random() * 100)}, 255, ${p.life / 30})`;
        ctx.fillRect(p.x, p.y, 5, 5);
      });
    }

    function createParticles(x, y) {
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          life: 30,
        });
      }
    }

    let messageTimeout;
    function showMessage(text) {
      const msgDiv = document.createElement('div');
      msgDiv.textContent = text;
      msgDiv.style.position = 'absolute';
      msgDiv.style.top = '50%';
      msgDiv.style.left = '50%';
      msgDiv.style.transform = 'translate(-50%, -50%)';
      msgDiv.style.fontSize = '2rem';
      msgDiv.style.fontWeight = '700';
      msgDiv.style.color = '#ff00ff';
      msgDiv.style.textShadow = '2px 2px 8px rgba(0,0,0,0.8)';
      msgDiv.style.zIndex = '20';
      msgDiv.style.pointerEvents = 'none';
      document.body.appendChild(msgDiv);

      clearTimeout(messageTimeout);
      messageTimeout = setTimeout(() => {
        msgDiv.remove();
      }, 2000);
    }

    function playSound(type) {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      if (type === 'throw') {
        oscillator.frequency.value = 200;
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
      } else if (type === 'hit') {
        oscillator.frequency.value = 800;
        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
      }
    }

    function endGame() {
      gameState = 'over';
      document.getElementById('hud').classList.add('hidden');
      document.getElementById('pauseBtn').classList.add('hidden');

      const finalMsg = finalMessages.find(m => score >= m.min && score <= m.max);
      document.getElementById('finalScore').textContent = `Score final: ${score} points`;
      document.getElementById('finalMessage').textContent = finalMsg ? finalMsg.msg : "Bien jou√© !";
      document.getElementById('gameOverScreen').classList.remove('hidden');
    }

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>