<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Malo's Revenge ‚Äî Ap√©ro Arena üç∑</title>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@400;600;700;800&display=swap" rel="stylesheet" />

  <style>
    :root{
      --bg1:#0b1020;
      --bg2:#141a33;
      --neon:#7c3aed;
      --neon2:#22d3ee;
      --gold:#fbbf24;
      --good:#34d399;
      --bad:#fb7185;
      --glass: rgba(255,255,255,.08);
      --glass2: rgba(255,255,255,.14);
      --stroke: rgba(255,255,255,.14);
      --shadow: rgba(0,0,0,.45);
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: "Oxanium", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 900px at 30% 20%, rgba(124,58,237,.28), transparent 55%),
                  radial-gradient(1000px 800px at 80% 60%, rgba(34,211,238,.22), transparent 50%),
                  linear-gradient(180deg, var(--bg1), var(--bg2));
      color:#fff;
      overflow:hidden;
      user-select:none;
      cursor: crosshair;
    }

    /* subtle animated grain */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      background:
        radial-gradient(circle at 20% 10%, rgba(255,255,255,.06), transparent 30%),
        radial-gradient(circle at 70% 40%, rgba(255,255,255,.05), transparent 28%),
        radial-gradient(circle at 40% 80%, rgba(255,255,255,.04), transparent 25%);
      mix-blend-mode: overlay;
      pointer-events:none;
      opacity:.55;
      animation: drift 8s ease-in-out infinite;
    }
    @keyframes drift{
      0%,100%{ transform: translate3d(0,0,0) scale(1); }
      50%{ transform: translate3d(-12px,10px,0) scale(1.02); }
    }

    #game{
      position:relative;
      width:100vw;
      height:100vh;
      overflow:hidden;
    }

    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:none;
    }

    /* HUD */
    #hud{
      position:absolute;
      inset:18px 18px auto 18px;
      display:none;
      gap:12px;
      align-items:flex-start;
      z-index:30;
      pointer-events:none;
    }

    .hudCard{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 10px 14px;
      min-width: 140px;
      box-shadow: 0 18px 40px var(--shadow);
      backdrop-filter: blur(14px);
    }

    .hudLabel{
      font-size: 11px;
      letter-spacing: .14em;
      text-transform: uppercase;
      color: rgba(255,255,255,.75);
      margin-bottom:4px;
    }

    .hudValue{
      font-size: 26px;
      font-weight: 800;
      line-height:1.05;
      text-shadow: 0 0 18px rgba(255,255,255,.18);
    }

    #hudScore .hudValue{ color: var(--gold); }
    #hudTime .hudValue{ color: var(--good); }
    #hudHits .hudValue{ color: var(--neon2); }

    #topRight{
      position:absolute;
      top:18px;
      right:18px;
      z-index:31;
      display:none;
      gap:10px;
      align-items:center;
    }

    .btn{
      font-family: "Oxanium", sans-serif;
      font-weight: 800;
      letter-spacing:.08em;
      text-transform: uppercase;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color: #fff;
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      box-shadow: 0 14px 34px var(--shadow);
      backdrop-filter: blur(14px);
    }
    .btn:hover{ transform: translateY(-2px); border-color: rgba(255,255,255,.25); }
    .btn:active{ transform: translateY(0); }

    /* Start overlay */
    #start{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:16px;
      z-index:50;
      background:
        radial-gradient(900px 650px at 50% 35%, rgba(124,58,237,.35), transparent 55%),
        radial-gradient(800px 600px at 65% 65%, rgba(34,211,238,.22), transparent 55%),
        linear-gradient(180deg, rgba(10,14,30,.65), rgba(10,14,30,.88));
      backdrop-filter: blur(14px);
    }

    .title{
      font-size: clamp(34px, 6vw, 70px);
      font-weight: 800;
      letter-spacing: .06em;
      line-height:1;
      margin:0;
      text-align:center;
      text-shadow:
        0 0 28px rgba(124,58,237,.35),
        0 0 24px rgba(34,211,238,.22),
        0 16px 60px rgba(0,0,0,.55);
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: 10px 14px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      backdrop-filter: blur(14px);
      box-shadow: 0 18px 42px var(--shadow);
      color: rgba(255,255,255,.9);
      font-weight:700;
      letter-spacing:.08em;
      text-transform: uppercase;
      font-size: 12px;
    }

    .panel{
      width:min(860px, calc(100vw - 32px));
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      box-shadow: 0 28px 70px rgba(0,0,0,.55);
      backdrop-filter: blur(16px);
      padding: 18px;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
    }

    .diff{
      border:none;
      cursor:pointer;
      border-radius: 18px;
      padding: 14px 14px;
      color:#fff;
      text-align:left;
      background: linear-gradient(135deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      border: 1px solid rgba(255,255,255,.16);
      transition: transform .15s ease, border-color .15s ease, box-shadow .15s ease;
      box-shadow: 0 18px 46px rgba(0,0,0,.45);
      position:relative;
      overflow:hidden;
      font-family: "Oxanium", sans-serif;
    }

    .diff::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(500px 220px at 30% 20%, rgba(34,211,238,.28), transparent 55%),
                  radial-gradient(420px 220px at 90% 80%, rgba(124,58,237,.32), transparent 55%);
      opacity:.8;
      pointer-events:none;
    }

    .diff:hover{
      transform: translateY(-3px);
      border-color: rgba(255,255,255,.28);
      box-shadow: 0 26px 64px rgba(0,0,0,.55);
    }

    .diffName{ position:relative; z-index:1; font-weight:800; letter-spacing:.1em; text-transform:uppercase; }
    .diffDesc{ position:relative; z-index:1; margin-top:6px; color: rgba(255,255,255,.78); font-weight:600; font-size:13px; line-height:1.3; }

    .hint{
      margin-top: 12px;
      color: rgba(255,255,255,.75);
      font-weight:600;
      line-height:1.55;
      text-align:center;
      font-size: 14px;
    }

    .kbd{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 2px 8px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.25);
      font-weight:800;
      letter-spacing:.06em;
      font-size: 12px;
      margin: 0 3px;
    }

    /* End overlay */
    #end{
      position:absolute;
      inset:0;
      display:none;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:16px;
      z-index:60;
      background: linear-gradient(180deg, rgba(10,14,30,.78), rgba(10,14,30,.92));
      backdrop-filter: blur(16px);
    }

    .endTitle{ font-size: clamp(28px, 5vw, 54px); font-weight: 900; letter-spacing:.06em; margin:0; }
    .endScore{ font-size: clamp(20px, 4vw, 34px); font-weight: 800; color: var(--gold); }
    .endMsg{ max-width: 860px; padding: 0 18px; text-align:center; color: rgba(255,255,255,.88); font-weight: 600; line-height:1.75; }

    /* Floating hit bubble (anchored near target, clamped inside viewport) */
    .hitBubble{
      position:absolute;
      z-index:80;
      max-width: min(360px, calc(100vw - 16px));
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(255,255,255,.92);
      color: #0b1020;
      font-weight: 800;
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
      border: 1px solid rgba(0,0,0,.08);
      pointer-events:none;
      transform-origin: left center;
      animation: pop .18s ease-out;
    }

    .hitBubble small{
      display:block;
      margin-top:4px;
      font-weight:700;
      opacity:.75;
      letter-spacing:.04em;
    }

    @keyframes pop{
      from{ transform: translate3d(0,6px,0) scale(.92); opacity:0; }
      to{ transform: translate3d(0,0,0) scale(1); opacity:1; }
    }

    /* little arrow */
    .hitBubble::after{
      content:"";
      position:absolute;
      width: 10px;
      height: 10px;
      background: rgba(255,255,255,.92);
      left: -5px;
      top: 16px;
      transform: rotate(45deg);
      border-left: 1px solid rgba(0,0,0,.08);
      border-bottom: 1px solid rgba(0,0,0,.08);
    }

    /* Combo banner */
    #combo{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%,-50%);
      font-size: clamp(34px, 6vw, 72px);
      font-weight: 900;
      letter-spacing:.06em;
      color: #fff;
      text-shadow:
        0 0 26px rgba(34,211,238,.35),
        0 0 32px rgba(124,58,237,.32),
        0 20px 70px rgba(0,0,0,.7);
      opacity:0;
      pointer-events:none;
      z-index:40;
    }
    #combo.show{ animation: combo .9s ease-out forwards; }
    @keyframes combo{
      0%{ opacity:0; transform: translate(-50%,-50%) scale(.75) rotate(-6deg); }
      20%{ opacity:1; transform: translate(-50%,-50%) scale(1.1) rotate(2deg); }
      70%{ opacity:1; transform: translate(-50%,-50%) scale(1.02) rotate(-1deg); }
      100%{ opacity:0; transform: translate(-50%,-50%) scale(.9) rotate(0deg); }
    }

    /* Mobile adjustments */
    @media (max-width: 900px){
      .grid{ grid-template-columns: repeat(2, 1fr); }
      #hud{ inset: 14px 14px auto 14px; }
      #topRight{ top:14px; right:14px; }
      .hudCard{ min-width: 120px; }
    }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="c"></canvas>

    <div id="hud">
      <div class="hudCard" id="hudScore"><div class="hudLabel">Score</div><div class="hudValue" id="score">0</div></div>
      <div class="hudCard" id="hudTime"><div class="hudLabel">Temps</div><div class="hudValue" id="time">60</div></div>
      <div class="hudCard" id="hudHits"><div class="hudLabel">Hits</div><div class="hudValue" id="hits">0</div></div>
    </div>

    <div id="topRight">
      <button class="btn" id="pauseBtn">‚è∏ Pause</button>
      <button class="btn" id="soundBtn" title="Activer/D√©sactiver le son">üîä Son</button>
    </div>

    <div id="combo"></div>

    <div id="start">
      <div class="badge">üç∑ Ap√©ro Arena ‚Ä¢ 1 fichier ‚Ä¢ GitHub Pages ready</div>
      <h1 class="title">MALO'S REVENGE</h1>
      <div class="panel">
        <div class="grid">
          <button class="diff" data-diff="easy"><div class="diffName">Easy</div><div class="diffDesc">Cool & smooth<br/>Pour s‚Äô√©chauffer.</div></button>
          <button class="diff" data-diff="medium"><div class="diffName">Medium</div><div class="diffDesc">√áa commence √† piquer<br/>mais c‚Äôest g√©rable.</div></button>
          <button class="diff" data-diff="hard"><div class="diffName">Hard</div><div class="diffDesc">R√©flexes obligatoires<br/>sinon c‚Äôest honteux.</div></button>
          <button class="diff" data-diff="insane"><div class="diffName">Insane</div><div class="diffDesc">Speedrun d‚Äôap√©ro<br/>√ßa part en orbite.</div></button>
        </div>
        <div class="hint">
          Clique pour <b>lancer un verre de vin</b> üç∑ vers une t√™te.<br/>
          <span class="kbd">P</span> pause ‚Ä¢ <span class="kbd">R</span> restart ‚Ä¢ Le son d√©marre au premier clic.
        </div>
      </div>
    </div>

    <div id="end">
      <h2 class="endTitle">FIN DE PARTIE</h2>
      <div class="endScore">Score : <span id="finalScore">0</span></div>
      <div class="endMsg" id="finalMsg"></div>
      <button class="btn" id="restartBtn">‚Üª Rejouer</button>
    </div>
  </div>

  <script>
    /**********************
     *  CONFIG (PHOTOS)
     *  - Mets les images au m√™me niveau que index.html : malo.jpg, marie.jpg, nico.jpg, valentine.jpg
     *  - Ou remplace par des URLs directes (ex: https://i.imgur.com/xxxx.jpg)
     **********************/
    const friends = [
      { id: "malo",      name: "Malo",      img: "malo.jpg" },
      { id: "marie",     name: "Marie",     img: "marie.jpg" },
      { id: "ptitnico",  name: "PtitNico",  img: "nico.jpg" },
      { id: "valentine", name: "Valentine", img: "valentine.jpg" },
    ];

    const diff = {
      easy:   { speed: 2.1, spawnMs: 1900, duration: 60, points: 10 },
      medium: { speed: 3.0, spawnMs: 1400, duration: 60, points: 15 },
      hard:   { speed: 4.2, spawnMs: 1000, duration: 60, points: 25 },
      insane: { speed: 5.5, spawnMs: 780,  duration: 60, points: 40 },
    };

    /**********************
     *  HIT MESSAGES (TES PHRASES ‚Äî CONSERV√âES)
     **********************/
    const hitMessagesByCharacter = {
      malo: [
        "C'est qui √ßa ?",
        "On t'a d√©j√† vu quelque part ?",
        "On va faire comme si rien ne s'√©tait pass√©.",
        "T'es perdu fr√©rot ?",
        "La vie est injuste!",
        // extras
        "Fr√©rot‚Ä¶ c'√©tait pas ton jour.",
        "Ok, j'avoue‚Ä¶ bien jou√©.",
      ],
      marie: [
        "Je vais te gifler !",
        "PAS d'accord.",
        "Oups,√ßa part en drame.",
        "T'as un probl√®me ?",
        "On va te d√©gommer",
        // extras
        "√áa va finir au tribunal.",
        "C'est officiel: tu cherches.",
      ],
      ptitnico: [
        "Rastafarai !",
        "On dirait un probl√®me.",
        "Bad vibes ",
        "Merci d'avoir tent√©.",
        "Tu t'acharnes ?",
        // extras
        "La vibe est cass√©e.",
        "C'est pas tr√®s zen √ßa.",
      ],
      valentine: [
        "Elle co√ªte cher !",
        "T'as vraiment cru que c'√©tait une bonne id√©e ?",
        "C'√©tait hors budget, d√©sol√©.",
        "Tout le monde n'a pas le niveau.",
        "Tu peux pas te le permettre.",
        // extras
        "Retourne en version gratuite.",
        "D√©sol√©e, c'est premium ici.",
      ],
    };

    const missMessages = [
      "Rat√©. Le verre a v√©cu sa meilleure vie.",
      "Oups. Mauvaise trajectoire, bonne intention.",
      "Tu visais la t√™te, pas l‚Äôambiance.",
      "√áa fr√¥le‚Ä¶ mais non.",
    ];

    const finalMessages = [
      { min: 0,   max: 80,   msg: "Tu √©tais l√† pour l'ambiance, pas pour la performance. üç∑" },
      { min: 81,  max: 200,  msg: "Correct ! Un ap√©ro honn√™te, pas plus. üòå" },
      { min: 201, max: 380,  msg: "Solide. Tu commences √† √™tre dangereux (gentiment). üòà" },
      { min: 381, max: 650,  msg: "Tr√®s chaud. Les verres volent, les egos tombent. üî•" },
      { min: 651, max: 9999, msg: "L√©gende. Le sommelier a d√©missionn√©. üèÜ" },
    ];

    /**********************
     *  DOM
     **********************/
    const gameEl = document.getElementById("game");
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const startEl = document.getElementById("start");
    const endEl = document.getElementById("end");
    const restartBtn = document.getElementById("restartBtn");

    const hudEl = document.getElementById("hud");
    const topRightEl = document.getElementById("topRight");
    const pauseBtn = document.getElementById("pauseBtn");
    const soundBtn = document.getElementById("soundBtn");

    const scoreEl = document.getElementById("score");
    const timeEl = document.getElementById("time");
    const hitsEl = document.getElementById("hits");
    const comboEl = document.getElementById("combo");
    const finalScoreEl = document.getElementById("finalScore");
    const finalMsgEl = document.getElementById("finalMsg");

    /**********************
     *  CANVAS SIZE
     **********************/
    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resize);

    /**********************
     *  HELPERS
     **********************/
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a,b) => a + Math.random() * (b-a);
    const pick = arr => arr[(Math.random() * arr.length) | 0];

    function drawImageCover(ctx, img, x, y, w, h){
      // center-crop like CSS object-fit: cover
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      if (!iw || !ih) return;
      const r = Math.max(w / iw, h / ih);
      const nw = iw * r;
      const nh = ih * r;
      const cx = x + (w - nw) / 2;
      const cy = y + (h - nh) / 2;
      ctx.drawImage(img, cx, cy, nw, nh);
    }

    function showCombo(n){
      comboEl.textContent = `COMBO x${n}`;
      comboEl.classList.remove("show");
      void comboEl.offsetWidth;
      comboEl.classList.add("show");
    }

    function showHitBubble(text, x, y, who){
      // x,y are in viewport coordinates (same as our canvas logical coords)
      const el = document.createElement("div");
      el.className = "hitBubble";
      el.innerHTML = `${escapeHtml(text)}<small>${escapeHtml(who)}</small>`;
      gameEl.appendChild(el);

      // initial position (to the right of the face)
      el.style.left = (x + 18) + "px";
      el.style.top  = (y - 18) + "px";

      // clamp inside viewport after we know its size
      const pad = 8;
      const r = el.getBoundingClientRect();
      let left = parseFloat(el.style.left);
      let top = parseFloat(el.style.top);

      // if it overflows on the right, flip to the left side
      if (left + r.width > window.innerWidth - pad){
        left = x - r.width - 18;
        el.style.transformOrigin = "right center";
        el.style.setProperty("--arrow", "left");
        // flip arrow
        el.style.setProperty("--flip", "1");
        el.style.setProperty("--flip", "1");
        el.style.setProperty("--flip", "1");
        el.style.setProperty("--flip", "1");
        // manually move arrow
        el.style.setProperty("--arrowSide", "right");
        el.style.setProperty("--arrowLeft", "auto");
      }

      // clamp within viewport
      left = clamp(left, pad, window.innerWidth - r.width - pad);
      top  = clamp(top,  pad, window.innerHeight - r.height - pad);
      el.style.left = left + "px";
      el.style.top  = top + "px";

      // If placed on left side, move arrow to right
      const placedLeft = (left < x);
      if (placedLeft){
        el.style.transformOrigin = "right center";
        el.style.setProperty("--arrowOnLeft", "0");
        el.style.setProperty("--arrowX", "auto");
        el.style.setProperty("--arrowR", "-5px");
        el.style.setProperty("--arrowL", "auto");
        el.style.setProperty("--arrow", "right");
        el.style.setProperty("--arrow", "right");
        el.style.setProperty("--arrow", "right");
        el.style.setProperty("--arrow", "right");
        // override pseudo positioning via inline style trick: add a class
        el.classList.add("leftSide");
      }

      setTimeout(() => {
        el.style.transition = "opacity .22s ease, transform .22s ease";
        el.style.opacity = "0";
        el.style.transform = "translateY(-6px) scale(.98)";
        setTimeout(() => el.remove(), 240);
      }, 1050);
    }

    function escapeHtml(str){
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    // tweak arrow when bubble is on the left
    const extraCSS = document.createElement("style");
    extraCSS.textContent = `
      .hitBubble.leftSide::after{
        left: auto;
        right: -5px;
        transform: rotate(225deg);
        border-left: none;
        border-bottom: none;
        border-right: 1px solid rgba(0,0,0,.08);
        border-top: 1px solid rgba(0,0,0,.08);
      }
    `;
    document.head.appendChild(extraCSS);

    /**********************
     *  AUDIO (ENTRAINANT)
     **********************/
    let audio = null;

    function initAudio(){
      if (audio) return audio;

      const AC = window.AudioContext || window.webkitAudioContext;
      const ctxA = new AC();

      const master = ctxA.createGain();
      master.gain.value = 0.55;

      const comp = ctxA.createDynamicsCompressor();
      comp.threshold.value = -18;
      comp.knee.value = 24;
      comp.ratio.value = 6;
      comp.attack.value = 0.003;
      comp.release.value = 0.12;

      master.connect(comp);
      comp.connect(ctxA.destination);

      // simple "color" filter for music
      const musicBus = ctxA.createGain();
      const sfxBus = ctxA.createGain();
      musicBus.gain.value = 0.9;
      sfxBus.gain.value = 1.0;

      const musicLP = ctxA.createBiquadFilter();
      musicLP.type = "lowpass";
      musicLP.frequency.value = 9500;
      musicLP.Q.value = 0.7;

      musicBus.connect(musicLP);
      musicLP.connect(master);
      sfxBus.connect(master);

      const state = {
        ctx: ctxA,
        enabled: true,
        bpm: 142,
        next: 0,
        timer: null,
        step: 0,
      };

      function now(){ return ctxA.currentTime; }

      function tone(freq, t0, dur, type, gain, out=musicBus){
        const o = ctxA.createOscillator();
        const g = ctxA.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, t0);
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(gain, t0 + 0.008);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
        o.connect(g);
        g.connect(out);
        o.start(t0);
        o.stop(t0 + dur + 0.02);
      }

      function noise(t0, dur, gain, hp=6000, out=sfxBus){
        const len = Math.max(1, Math.floor(ctxA.sampleRate * dur));
        const buf = ctxA.createBuffer(1, len, ctxA.sampleRate);
        const d = buf.getChannelData(0);
        for (let i=0;i<len;i++) d[i] = Math.random()*2-1;
        const src = ctxA.createBufferSource();
        src.buffer = buf;

        const f = ctxA.createBiquadFilter();
        f.type = "highpass";
        f.frequency.setValueAtTime(hp, t0);

        const g = ctxA.createGain();
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(gain, t0 + 0.004);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        src.connect(f);
        f.connect(g);
        g.connect(out);
        src.start(t0);
        src.stop(t0 + dur + 0.02);
      }

      // SFX: throw (glass whoosh + clink)
      function sfxThrow(){
        if (!state.enabled) return;
        const t = now();
        noise(t, 0.05, 0.07, 1800, sfxBus);
        tone(950, t, 0.06, "sine", 0.10, sfxBus);
        tone(1550, t + 0.012, 0.05, "sine", 0.07, sfxBus);
      }

      // SFX: hit (thud + glass crackle)
      function sfxHit(){
        if (!state.enabled) return;
        const t = now();
        tone(90, t, 0.10, "sine", 0.22, sfxBus);
        tone(2200, t + 0.02, 0.07, "square", 0.10, sfxBus);
        noise(t + 0.018, 0.10, 0.12, 1200, sfxBus);
      }

      function sfxMiss(){
        if (!state.enabled) return;
        const t = now();
        tone(420, t, 0.08, "triangle", 0.07, sfxBus);
        tone(330, t + 0.03, 0.09, "sine", 0.05, sfxBus);
      }

      // Music: upbeat electro/chiptune-ish groove
      // Pattern: kick/snare/hat + bass + arp lead
      const kickSteps = new Set([0, 4, 8, 12, 14]);
      const snrSteps  = new Set([4, 12]);
      const hatSteps  = new Set([2, 6, 10, 14]);

      const bassSeq = [110, 110, 98, 110, 130, 110, 98, 146]; // 8-step
      const arp = [523.25, 659.25, 783.99, 659.25]; // C5 E5 G5 E5

      function schedule(){
        if (!state.enabled) return;
        const spb = 60 / state.bpm;
        const stepDur = 0.25 * spb;

        while (state.next < now() + 0.12){
          const s = state.step % 16;
          const t = state.next;

          // Kick
          if (kickSteps.has(s)){
            // short pitch drop
            const o = ctxA.createOscillator();
            const g = ctxA.createGain();
            o.type = "sine";
            o.frequency.setValueAtTime(150, t);
            o.frequency.exponentialRampToValueAtTime(46, t + 0.11);
            g.gain.setValueAtTime(0.0001, t);
            g.gain.exponentialRampToValueAtTime(0.26, t + 0.005);
            g.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);
            o.connect(g);
            g.connect(musicBus);
            o.start(t);
            o.stop(t + 0.18);
          }

          // Snare
          if (snrSteps.has(s)){
            noise(t, 0.06, 0.10, 2000, musicBus);
            tone(190, t, 0.05, "triangle", 0.07, musicBus);
          }

          // Hat
          if (hatSteps.has(s)){
            noise(t, 0.03, 0.05, 7000, musicBus);
          }

          // Bass (on 8th steps)
          if (s % 2 === 0){
            const f = bassSeq[(s/2) % bassSeq.length];
            tone(f, t, 0.14, "sawtooth", 0.065, musicBus);
          }

          // Arp lead (syncopated)
          if ([1, 5, 9, 13].includes(s)){
            const f = arp[(s/4) | 0];
            tone(f, t, 0.10, "square", 0.05, musicBus);
            tone(f/2, t, 0.10, "triangle", 0.03, musicBus);
          }

          state.step++;
          state.next += stepDur;
        }
      }

      function startMusic(){
        state.next = now();
        state.step = 0;
        if (state.timer) clearInterval(state.timer);
        state.timer = setInterval(schedule, 25);
      }

      function stopMusic(){
        if (state.timer) clearInterval(state.timer);
        state.timer = null;
      }

      audio = {
        state,
        startMusic,
        stopMusic,
        sfxThrow,
        sfxHit,
        sfxMiss,
        async resume(){
          if (ctxA.state === "suspended") {
            try { await ctxA.resume(); } catch(e) {}
          }
        }
      };

      startMusic();
      return audio;
    }

    async function ensureAudio(){
      const a = initAudio();
      await a.resume();
      return a;
    }

    function setSoundEnabled(on){
      const a = initAudio();
      a.state.enabled = on;
      soundBtn.textContent = on ? "üîä Son" : "üîá Son";
      if (!on){
        // keep scheduler but silence via master gain?
        // easiest: set master gain low
        // (leave dynamics stable)
        // We'll just rely on enabled flag for new notes.
      }
    }

    /**********************
     *  GAME STATE
     **********************/
    let S = null;

    function newState(){
      return {
        running:false,
        paused:false,
        d:"easy",
        score:0,
        hits:0,
        combo:0,
        timeLeft:60,
        targets:[],
        projectiles:[],
        particles:[],
        spawnT:0,
        lastT:0,
        timerId:null,
      };
    }

    function reset(){
      S = newState();
      updateHud();
    }

    function updateHud(){
      scoreEl.textContent = S.score;
      timeEl.textContent = S.timeLeft;
      hitsEl.textContent = S.hits;
    }

    /**********************
     *  TARGETS
     **********************/
    function spawnTarget(){
      const f = friends[(Math.random()*friends.length)|0];
      const size = 148; // bigger faces (jeu vid√©o vibe)

      const x = rand(20, window.innerWidth - size - 20);
      const y = rand(90, window.innerHeight - size - 140);

      const sp = diff[S.d].speed;
      const vx = rand(-1, 1) * sp;
      const vy = rand(-1, 1) * sp;

      const img = new Image();
      img.crossOrigin = "anonymous";
      img.src = f.img;

      S.targets.push({
        f,
        x,
        y,
        vx,
        vy,
        size,
        img,
        wob: rand(0, Math.PI*2),
      });
    }

    function updateTargets(dt){
      for (const t of S.targets){
        t.wob += dt * 4.2;
        const wobble = Math.sin(t.wob) * 0.35;

        t.x += (t.vx + wobble) * dt * 60;
        t.y += (t.vy - wobble) * dt * 60;

        if (t.x < 12){ t.x = 12; t.vx = Math.abs(t.vx); }
        if (t.x > window.innerWidth - t.size - 12){ t.x = window.innerWidth - t.size - 12; t.vx = -Math.abs(t.vx); }
        if (t.y < 80){ t.y = 80; t.vy = Math.abs(t.vy); }
        if (t.y > window.innerHeight - t.size - 120){ t.y = window.innerHeight - t.size - 120; t.vy = -Math.abs(t.vy); }
      }
    }

    function drawTargets(){
      for (const t of S.targets){
        const cx = t.x + t.size/2;
        const cy = t.y + t.size/2;
        const r = t.size/2;

        // glow ring
        ctx.save();
        ctx.shadowColor = "rgba(34,211,238,.35)";
        ctx.shadowBlur = 22;

        // outer ring
        ctx.beginPath();
        ctx.arc(cx, cy, r + 6, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,.10)";
        ctx.fill();

        // mask circle
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.closePath();
        ctx.save();
        ctx.clip();

        if (t.img.complete && (t.img.naturalWidth || t.img.width)){
          drawImageCover(ctx, t.img, t.x, t.y, t.size, t.size);
        } else {
          // fallback placeholder
          ctx.fillStyle = "rgba(255,255,255,.12)";
          ctx.fillRect(t.x, t.y, t.size, t.size);
        }

        // subtle overlay
        const g = ctx.createLinearGradient(t.x, t.y, t.x + t.size, t.y + t.size);
        g.addColorStop(0, "rgba(0,0,0,.06)");
        g.addColorStop(1, "rgba(0,0,0,.22)");
        ctx.fillStyle = g;
        ctx.fillRect(t.x, t.y, t.size, t.size);

        ctx.restore();

        // border
        ctx.strokeStyle = "rgba(255,255,255,.68)";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.stroke();

        // name tag
        ctx.shadowColor = "transparent";
        ctx.fillStyle = "rgba(0,0,0,.55)";
        const tagW = ctx.measureText(t.f.name).width + 22;
        const tagX = cx - tagW/2;
        const tagY = t.y + t.size + 8;
        roundRect(ctx, tagX, tagY, tagW, 22, 10);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "700 13px Oxanium";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(t.f.name, cx, tagY + 11);

        ctx.restore();
      }
    }

    function roundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    /**********************
     *  PROJECTILES (LANCER DE VERRE DE VIN ‚Äî PRO)
     **********************/
    function throwWine(tx, ty){
      const fromX = window.innerWidth / 2;
      const fromY = window.innerHeight - 80;

      const dx = tx - fromX;
      const dy = ty - fromY;
      const dist = Math.max(1, Math.hypot(dx, dy));

      const speed = 1200; // px/s
      const vx = (dx / dist) * speed;
      const vy = (dy / dist) * speed;

      S.projectiles.push({
        x: fromX,
        y: fromY,
        vx,
        vy,
        life: 0.55, // seconds
        rot: rand(0, Math.PI*2),
        rvel: rand(-10, 10),
      });
    }

    function updateProjectiles(dt){
      for (let i=S.projectiles.length-1;i>=0;i--){
        const p = S.projectiles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.rot += p.rvel * dt;
        p.life -= dt;

        // trail particles
        if (Math.random() < 0.8){
          S.particles.push({
            x: p.x,
            y: p.y,
            vx: rand(-40,40),
            vy: rand(-40,40),
            life: rand(0.16, 0.26),
            size: rand(2,4),
            col: `rgba(251,191,36,${rand(0.35,0.75)})`,
          });
        }

        if (p.life <= 0 || p.x < -80 || p.x > window.innerWidth+80 || p.y < -80 || p.y > window.innerHeight+80){
          S.projectiles.splice(i,1);
          // small miss feedback (sometimes)
          if (Math.random() < 0.4){
            audio?.sfxMiss?.();
            showHitBubble(pick(missMessages), clamp(p.x, 60, window.innerWidth-60), clamp(p.y, 80, window.innerHeight-120), "Miss");
          }
        }
      }
    }

    function drawProjectiles(){
      ctx.save();
      ctx.font = "44px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const p of S.projectiles){
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.shadowColor = "rgba(251,191,36,.35)";
        ctx.shadowBlur = 22;
        ctx.fillText("üç∑", 0, 0);
        ctx.restore();
      }
      ctx.restore();
    }

    /**********************
     *  PARTICLES
     **********************/
    function burst(x,y){
      for (let i=0;i<18;i++){
        S.particles.push({
          x, y,
          vx: rand(-260,260),
          vy: rand(-320,200),
          life: rand(0.25, 0.45),
          size: rand(2,5),
          col: `rgba(34,211,238,${rand(0.25,0.8)})`,
        });
      }
      for (let i=0;i<10;i++){
        S.particles.push({
          x, y,
          vx: rand(-220,220),
          vy: rand(-220,220),
          life: rand(0.2, 0.35),
          size: rand(3,6),
          col: `rgba(124,58,237,${rand(0.2,0.7)})`,
        });
      }
    }

    function updateParticles(dt){
      for (let i=S.particles.length-1;i>=0;i--){
        const p = S.particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= Math.pow(0.08, dt); // friction
        p.vy += 520 * dt; // gravity
        p.life -= dt;
        if (p.life <= 0) S.particles.splice(i,1);
      }
    }

    function drawParticles(){
      for (const p of S.particles){
        ctx.fillStyle = p.col;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
      }
    }

    /**********************
     *  COLLISIONS
     **********************/
    function collide(){
      for (let pi=S.projectiles.length-1; pi>=0; pi--){
        const p = S.projectiles[pi];
        for (let ti=S.targets.length-1; ti>=0; ti--){
          const t = S.targets[ti];
          const cx = t.x + t.size/2;
          const cy = t.y + t.size/2;
          const r = t.size/2;
          const d = Math.hypot(p.x - cx, p.y - cy);
          if (d < r - 6){
            // HIT
            S.projectiles.splice(pi,1);
            S.targets.splice(ti,1);

            S.hits++;
            S.combo++;
            S.score += diff[S.d].points + Math.min(40, (S.combo-1) * 2);
            updateHud();

            // effects
            audio?.sfxHit?.();
            burst(cx, cy);
            // funny emoji pop (subtle)
            if (Math.random() < 0.6){
              showHitBubble("üñï", cx, cy, t.f.name);
            }

            // message near face (clamped ‚Äî won't go off-screen)
            const msg = pick(hitMessagesByCharacter[t.f.id] || ["Touch√© !"]);
            showHitBubble(msg, cx + r + 8, cy, t.f.name);

            if (S.combo === 3 || S.combo === 5 || (S.combo > 5 && S.combo % 5 === 0)){
              showCombo(S.combo);
            }

            break;
          }
        }
      }
    }

    /**********************
     *  LOOP
     **********************/
    function loop(ts){
      if (!S.running) return;
      if (!S.lastT) S.lastT = ts;
      const dt = clamp((ts - S.lastT) / 1000, 0, 0.033);
      S.lastT = ts;

      if (!S.paused){
        S.spawnT += dt * 1000;
        if (S.spawnT >= diff[S.d].spawnMs){
          S.spawnT = 0;
          spawnTarget();
        }

        updateTargets(dt);
        updateProjectiles(dt);
        updateParticles(dt);
        collide();
      }

      // draw
      ctx.clearRect(0,0,window.innerWidth, window.innerHeight);

      // parallax glow vignette
      const vg = ctx.createRadialGradient(window.innerWidth*0.5, window.innerHeight*0.45, 120, window.innerWidth*0.5, window.innerHeight*0.5, Math.max(window.innerWidth, window.innerHeight));
      vg.addColorStop(0, "rgba(255,255,255,.03)");
      vg.addColorStop(1, "rgba(0,0,0,.28)");
      ctx.fillStyle = vg;
      ctx.fillRect(0,0,window.innerWidth, window.innerHeight);

      drawParticles();
      drawTargets();
      drawProjectiles();

      requestAnimationFrame(loop);
    }

    /**********************
     *  TIMER
     **********************/
    function startTimer(){
      if (S.timerId) clearInterval(S.timerId);
      S.timerId = setInterval(() => {
        if (!S.running || S.paused) return;
        S.timeLeft--;
        updateHud();
        if (S.timeLeft <= 0) endGame();
      }, 1000);
    }

    /**********************
     *  START / END
     **********************/
    async function startGame(which){
      reset();
      S.d = which;
      S.timeLeft = diff[which].duration;

      await ensureAudio();
      initAudio().startMusic();

      startEl.style.display = "none";
      endEl.style.display = "none";
      canvas.style.display = "block";
      hudEl.style.display = "flex";
      topRightEl.style.display = "flex";

      S.running = true;
      S.paused = false;
      pauseBtn.textContent = "‚è∏ Pause";

      // spawn initial targets
      for (let i=0;i<4;i++) spawnTarget();

      startTimer();
      requestAnimationFrame(loop);
    }

    function endGame(){
      S.running = false;
      if (S.timerId) clearInterval(S.timerId);

      initAudio().stopMusic();

      canvas.style.display = "none";
      hudEl.style.display = "none";
      topRightEl.style.display = "none";

      finalScoreEl.textContent = S.score;
      let msg = finalMessages[0].msg;
      for (const m of finalMessages){
        if (S.score >= m.min && S.score <= m.max){ msg = m.msg; break; }
      }
      finalMsgEl.textContent = msg;
      endEl.style.display = "flex";
    }

    function restart(){
      endEl.style.display = "none";
      startEl.style.display = "flex";
    }

    function togglePause(){
      if (!S.running) return;
      S.paused = !S.paused;
      pauseBtn.textContent = S.paused ? "‚ñ∂ Reprendre" : "‚è∏ Pause";
    }

    /**********************
     *  INPUTS
     **********************/
    canvas.addEventListener("click", async (e) => {
      if (!S.running || S.paused) return;
      await ensureAudio();
      initAudio().sfxThrow();

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      throwWine(x, y);
    });

    document.querySelectorAll(".diff").forEach(btn => {
      btn.addEventListener("click", () => startGame(btn.dataset.diff));
    });

    restartBtn.addEventListener("click", restart);
    pauseBtn.addEventListener("click", togglePause);

    soundBtn.addEventListener("click", async () => {
      await ensureAudio();
      const a = initAudio();
      setSoundEnabled(!a.state.enabled);
    });

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "p") togglePause();
      if (k === "r"){
        if (S.running) endGame();
        restart();
      }
    });

    /**********************
     *  INIT
     **********************/
    reset();
    resize();
    setSoundEnabled(true);
  </script>
</body>
</html>